# Python 帶參數的裝飾器進階教學

## 帶參數的裝飾器進階概念

在[上一章](./ch11.md)我們已經學習了裝飾器的基本概念和用法。這一章節我們將深入探討一個更進階的主題：**帶參數的裝飾器**。

## 什麼是帶參數的裝飾器？

帶參數的裝飾器是一種可以接受外部參數來調整其行為的裝飾器。換句話說，我們不只是裝飾一個函數，還能通過參數來控制裝飾器的工作方式。

**基本結構：**
```python
def decorator_factory(parameter):
    def decorator(func):
        def wrapper(*args, **kwargs):
            # 使用parameter進行一些操作
            result = func(*args, **kwargs)
            # 可能的後續處理
            return result
        return wrapper
    return decorator
```

這種結構有三層嵌套：
1. 最外層函數 `decorator_factory` 接收裝飾器參數
2. 中間層函數 `decorator` 接收被裝飾的函數
3. 最內層函數 `wrapper` 包裝實際執行的邏輯

## RPG遊戲中的進階裝飾器應用

### 範例 1：技能冷卻時間裝飾器

假設我們開發的RPG遊戲中，不同技能有不同的冷卻時間。我們可以通過一個帶參數的裝飾器來實現：

```python
import time
from functools import wraps

def cooldown(seconds):
    def decorator(func):
        last_called = {}
        
        @wraps(func)
        def wrapper(character, *args, **kwargs):
            current_time = time.time()
            if character in last_called and current_time - last_called[character] < seconds:
                remaining = seconds - (current_time - last_called[character])
                print(f"{character}的技能 {func.__name__} 還在冷卻中，剩餘 {remaining:.1f} 秒")
                return None
            
            result = func(character, *args, **kwargs)
            last_called[character] = current_time
            return result
        
        return wrapper
    return decorator

@cooldown(5)  # 冷卻5秒
def fire_ball(character, target):
    print(f"{character} 向 {target} 釋放了火球術，造成100點傷害！")

@cooldown(2)  # 冷卻2秒
def quick_slash(character, target):
    print(f"{character} 對 {target} 使用快速斬擊，造成50點傷害！")

# 測試技能冷卻
fire_ball("魔法師", "哥布林")
fire_ball("魔法師", "哥布林")  # 應該顯示冷卻中
quick_slash("戰士", "史萊姆")
quick_slash("戰士", "史萊姆")  # 應該顯示冷卻中
time.sleep(2)
quick_slash("戰士", "史萊姆")  # 冷卻已過，可以再次使用
fire_ball("魔法師", "哥布林")  # 仍在冷卻中
```

**說明：**
1. `cooldown` 是一個裝飾器工廠函數，接收 `seconds` 參數
2. `decorator` 創建一個字典來追蹤每個角色上次使用技能的時間
3. `@wraps(func)` 用於保留原函數的元數據
4. `wrapper` 檢查是否過了冷卻時間：若未過則顯示剩餘時間；若已過則執行技能並記錄時間

### 範例 2：技能消耗與效果增強裝飾器

在RPG遊戲中，不同技能可能需要消耗不同資源且有不同增益效果：

```python
def skill_effect(mp_cost, boost_percentage=0):
    def decorator(func):
        @wraps(func)
        def wrapper(character, target, *args, **kwargs):
            # 假設character是具有mp屬性的對象
            if hasattr(character, "mp") and character.mp >= mp_cost:
                character.mp -= mp_cost
                print(f"{character.name} 消耗 {mp_cost} 魔力值")
                
                # 如果有增益效果
                original_damage = func(character, target, *args, **kwargs)
                if boost_percentage > 0 and original_damage:
                    boost_amount = original_damage * (boost_percentage / 100)
                    total_damage = original_damage + boost_amount
                    print(f"技能增益: +{boost_percentage}%, 總傷害: {total_damage}")
                    return total_damage
                return original_damage
            else:
                print(f"{character.name if hasattr(character, 'name') else character} 魔力不足！")
                return 0
                
        return wrapper
    return decorator

class Character:
    def __init__(self, name, mp=100):
        self.name = name
        self.mp = mp

@skill_effect(mp_cost=30, boost_percentage=20)
def lightning_strike(character, target):
    base_damage = 80
    print(f"{character.name} 對 {target} 施放閃電打擊，造成 {base_damage} 點基礎傷害")
    return base_damage

@skill_effect(mp_cost=10)
def heal(character, target):
    heal_amount = 50
    print(f"{character.name} 對 {target} 施放治療，恢復 {heal_amount} 點生命值")
    return heal_amount

# 測試技能效果
wizard = Character("巫師", mp=100)
warrior = Character("戰士", mp=5)

lightning_strike(wizard, "巨龍")  # 成功施放，有20%加成
heal(wizard, "戰士")  # 成功施放治療
lightning_strike(wizard, "巨龍")  # 魔力不足
lightning_strike(warrior, "史萊姆")  # 魔力不足
```

**說明：**
1. `skill_effect` 是一個帶參數的裝飾器，接收 `mp_cost` 和可選的 `boost_percentage`
2. 裝飾器檢查角色是否有足夠的魔力施放技能
3. 若有增益效果，計算額外傷害並顯示總傷害
4. 不同技能可以使用相同的裝飾器但參數不同

## 裝飾器鏈

多個裝飾器可以同時應用於一個函數，形成**裝飾器鏈**：

```python
@decorator_a
@decorator_b
@decorator_c
def function():
    pass
```

裝飾器的執行順序是**自下而上**的，即：先應用`decorator_c`，再`decorator_b`，最後`decorator_a`。

### RPG遊戲中的裝飾器鏈範例

```python
def log_skill(func):
    @wraps(func)
    def wrapper(character, target, *args, **kwargs):
        print(f"[記錄] {character.name} 正在對 {target} 使用 {func.__name__}")
        result = func(character, target, *args, **kwargs)
        print(f"[記錄] {func.__name__} 技能效果結束")
        return result
    return wrapper

def critical_chance(chance_percentage):
    def decorator(func):
        @wraps(func)
        def wrapper(character, target, *args, **kwargs):
            import random
            is_critical = random.randint(1, 100) <= chance_percentage
            
            result = func(character, target, *args, **kwargs)
            
            if result and is_critical:
                critical_damage = result * 2
                print(f"暴擊！傷害加倍: {result} → {critical_damage}")
                return critical_damage
            return result
        return wrapper
    return decorator

@log_skill
@critical_chance(30)
@skill_effect(mp_cost=25, boost_percentage=10)
def frost_nova(character, target):
    base_damage = 70
    print(f"{character.name} 釋放冰霜新星，對 {target} 造成 {base_damage} 點冰霜傷害")
    return base_damage

# 測試裝飾器鏈
mage = Character("法師", mp=100)
frost_nova(mage, "獸人群")
```

**說明：**
1. `frost_nova` 函數被三個裝飾器裝飾
2. 執行順序是: `skill_effect` → `critical_chance` → `log_skill`
3. 先檢查魔力消耗和增益，然後判斷是否暴擊，最後記錄日誌

## 實際應用場景

帶參數的裝飾器在許多領域都有廣泛應用：

1. **Web框架中的路由系統**：Flask/Django 使用裝飾器定義路由規則
2. **性能監控**：計時、記錄函數執行時間
3. **訪問控制**：根據用戶角色限制功能訪問
4. **緩存機制**：依據參數決定緩存策略
5. **重試機制**：根據參數決定重試次數和間隔

## 總結

帶參數的裝飾器是Python中非常靈活的功能，它能讓我們動態地改變裝飾器的行為。在RPG遊戲開發中，這種靈活性特別有用：

- 可以為不同角色技能設置不同的冷卻時間
- 可以實現不同的資源消耗及效果增益
- 通過裝飾器鏈組合多種效果

理解帶參數的裝飾器將使你的Python程式更具模組化和靈活性。
